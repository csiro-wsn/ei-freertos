##############################################################################
# Tool Settings
##############################################################################

JLINK_INTERFACE 	:= $(shell python3 -m programming.jlink --target $(TARGET) --print interface)
JLINK_SPEED			:= $(shell python3 -m programming.jlink --target $(TARGET) --print speed)
JLINK_CPU			:= $(shell python3 -m programming.jlink --target $(TARGET) --print cpu)

GDB_PORT			:= 2331
GDB_CPU				:= $(shell python3 -m programming.jlink --target $(TARGET) --print gdb_cpu)

ifdef JLINK
JLINK_SN_EXE=-SelectEmuBySN $(JLINK)
JLINK_SN_PYTHON=--jlink $(JLINK)
else
JLINK_SN_EXE=
JLINK_SN_PYTHON=
endif

ifdef REMOTE
ifeq ($(REMOTE),localhost)
REMOTE_JLINK=--remote 127.0.0.1:19020
else
REMOTE_JLINK=--remote $(REMOTE)
endif
else
REMOTE_JLINK=
endif

##############################################################################
# Prerequisite Rules
##############################################################################

# Output files depend on the directories they will be housed in
OUTPUT_DIRS := $(ARCH_LIB_DIR) $(PLATFORM_LIB_DIR) $(OBJ_DIR) $(foreach lib, $(ARCH_LIBS), $(ARCH_LIB_DIR)/$(lib)) $(foreach lib, $(PLATFORM_LIBS), $(PLATFORM_LIB_DIR)/$(lib))
$(OUTPUT_DIRS):
	$(Q)mkdir -p $@

# We want to ensure autogenerated files exist before compiling other CSIRO files
# But we dont want to recompile all the files whenever an autogenerated file changes
$(APPLICATION_SRCS) $(CORE_CSIRO_SRCS): | $(GENERATED_SRCS)

##############################################################################
# Charmeleon Files (Gauranteed to always change [Build Timestamps etc])
##############################################################################

.PHONY: $(INC_DIR)/rpc_server.h
.PHONY: $(CORE_CSIRO_DIR)/platform/common/src/build_info.c

##############################################################################
# List Processing
##############################################################################

# List of all compiled libraries in final application
APP_LIBS := $(foreach lib, $(PLATFORM_LIBS), $(PLATFORM_LIB_DIR)/lib$(lib).a) $(foreach lib, $(ARCH_LIBS), $(ARCH_LIB_DIR)/lib$(lib).a) 

# Add include paths to CFLAGS
CFLAGS += -I$(INC_DIR)
CFLAGS += $(foreach dir, $(APPLICATION_INCS), -I$(dir))
CFLAGS += $(foreach lib, $(ARCH_LIBS), $(foreach dir, $($(lib)_INCS), -I$(dir)))
CFLAGS += $(foreach lib, $(ARCH_LIBS), $(foreach dir, $($(lib)_SYS_INCS), -isystem$(dir)))

CFLAGS += $(foreach lib, $(PLATFORM_LIBS), $(foreach dir, $($(lib)_INCS), -I$(dir)))
CFLAGS += $(foreach lib, $(PLATFORM_LIBS), $(foreach dir, $($(lib)_SYS_INCS), -isystem$(dir)))

##############################################################################
# Autogeneration macros
##############################################################################

# Object files, stored in variable $(1), generated from SRC_LIST $(2), output to directory $(3)
define OBJ_FILES_FROM_SRC
$(eval $(1) := $(patsubst %.c, $(3)/%.o, $(notdir $($(2))))) \
$(eval $(1) := $(patsubst %.s, $(3)/%.o, $($(1)))) \
$(eval $(1) := $(patsubst %.S, $(3)/%.o, $($(1))))
endef

# Archive the Library $(1) into folder $(2)
define LIB_ARCHIVER
lib$(1): $(2)/lib$(1).a
$(2)/lib$(1).a: $($(1)_OBJS) | $(2)
	$(TRACE_AR)
	$(Q)$(AR) $(ARFLAGS) $$@ $$^
endef

# Compilation rule generator for object files in directory $(2)
# For all files with matching names in directory $(1)
# Additional CFLAGS passed in as $(3)
# Output directories are created if not existing
define COMPILE_RULES
$(2)/%.o: $(1)%.c | $(2)
	$(TRACE_CC)
	$(Q)$(CC) -MMD -c $(CFLAGS) $(3) $$< -o $$@
$(2)/%.o: $(1)%.s | $(2)
	$(TRACE_AS)
	$(Q)$(AS) -c $(ASFLAGS) $(3) $$< -o $$@
$(2)/%.o: $(1)%.S | $(2)
	$(TRACE_AS)
	$(Q)$(AS) -c $(ASFLAGS) $(3) $$< -o $$@
endef

##############################################################################
# Macro Application
##############################################################################

# Generate corresponding object filenames from specified application sources
APP_SRCS := $(APPLICATION_SRCS) $(GENERATED_SRCS)
$(call OBJ_FILES_FROM_SRC,APP_OBJS,APP_SRCS,$(OBJ_DIR))

# Generate corresponding object filenames from specified library sources
ALL_LIBS := $(PLATFORM_LIBS) $(ARCH_LIBS)
$(foreach lib, $(ARCH_LIBS), $(call OBJ_FILES_FROM_SRC,$(lib)_OBJS,$(lib)_SRCS,$(ARCH_LIB_DIR)/$(lib)))
$(foreach lib, $(PLATFORM_LIBS), $(call OBJ_FILES_FROM_SRC,$(lib)_OBJS,$(lib)_SRCS,$(PLATFORM_LIB_DIR)/$(lib)))

# Create unique list of application source directories
APP_SRC_DIRS := $(sort $(dir $(APP_SRCS)))
# Create unique list of source directories for each library
$(foreach lib, $(ALL_LIBS), $(eval $(lib)_SRC_DIRS := $(sort $(dir $($(lib)_SRCS)))))

# Automagically setup compilation rules for all source directories
$(foreach dir, $(APP_SRC_DIRS), $(eval $(call COMPILE_RULES,$(dir),$(OBJ_DIR),$(WARNINGS))))

$(foreach lib, $(ARCH_LIBS), $(foreach dir, $($(lib)_SRC_DIRS), $(eval $(call COMPILE_RULES,$(dir),$(ARCH_LIB_DIR)/$(lib),$($(lib)_CFLAGS)))))
$(foreach lib, $(PLATFORM_LIBS), $(foreach dir, $($(lib)_SRC_DIRS), $(eval $(call COMPILE_RULES,$(dir),$(PLATFORM_LIB_DIR)/$(lib),$($(lib)_CFLAGS)))))

# Create targets for library files
$(foreach lib, $(ARCH_LIBS), $(eval $(call LIB_ARCHIVER,$(lib),$(ARCH_LIB_DIR))))
$(foreach lib, $(PLATFORM_LIBS), $(eval $(call LIB_ARCHIVER,$(lib),$(PLATFORM_LIB_DIR))))

##############################################################################
# RPC Generation
##############################################################################

RPC_SRCS := $(wildcard $(CSIRO_RPC_DIR)/common/py/*.py)
RPC_SRCS += $(wildcard $(CSIRO_RPC_DIR)/common/src/*.rpc)
RPC_SRCS += $(wildcard $(CSIRO_RPC_DIR)/$(CPU_ARCH)/src/*.rpc)
RPC_SRCS += $(wildcard $(CSIRO_RPC_DIR)/$(CPU_ARCH)/$(TARGET)/src/*.rpc)

# Generated source files depend on the primary header file
$(SRC_DIR)/rpc_server_$(TARGET).c: $(INC_DIR)/rpc_server.h
$(SRC_DIR)/rpc_client_$(TARGET).c: $(INC_DIR)/rpc_server.h

# Rule to build the header file 
$(INC_DIR)/rpc_server.h: $(CSIRO_RPC_DIR)/default_rpcs.txt $(APP_ROOT)/rpc_list.txt $(RPC_SRCS)
	@echo "  PY        Generating RPC artifacts"
	@keygen --actionDir $(CORE_CSIRO_DIR)/rpc --skipDevel && \
	rpcgen --app_dir $(APP_ROOT) --rpc_dir $(CORE_CSIRO_DIR)/rpc --rpcs $(APP_ROOT)/rpc_list.txt --arch $(CPU_ARCH) --target $(TARGET)

##############################################################################
# Manual Tooling
##############################################################################

.PHONY: vscode
## Automatically generate vscode environment for development
vscode:
	$(REPO_ROOT)/tools/vscode/generate_settings.py --dest $(REPO_ROOT)/.vscode --python $(shell which python3)
	$(REPO_ROOT)/tools/vscode/generate_cpp_properties.py --dest $(REPO_ROOT)/.vscode --app $(PROJ_NAME) --target $(TARGET) --compiler $(shell which $(CC)) --app_dir $(shell pwd)

.PHONY: tdf
## Regenerate tdf_auto.h and tdf_struct.h
tdf: 
	tdf3tool --output $(CORE_CSIRO_DIR)/libraries/

.PHONY: stack
## Get stack usage of functions
stack: $(OBJ_DIR)/$(PROJ_NAME).elf
	@cp $(REPO_ROOT)/core_external/StackUsage/builtin.msu_master $(LIB_DIR)/builtin.msu
	@$(REPO_ROOT)/core_external/StackUsage/WCS.py --readelf $(READELF) --objs "$(DBG_DIR),$(LIB_DIR)"

.PHONY: size
## Prints list of variables in a binary sorted by file size
size: debug
	nm --print-size --size-sort --radix=d ./obj_$(TARGET)/dbg/$(PROJ_NAME).elf | grep " [bBdD] "
	# nm --print-size --size-sort --radix=d ./obj_$(TARGET)/dbg/$(PROJ_NAME).elf

##############################################################################
# Application Artifacts
##############################################################################

# Setup Header Dependencies for all object files
LIB_DEP = $(foreach lib, $(OUTPUT_LIBS), $($(lib)_OBJS:%.o=%.d))
OBJ_DEP = $(APP_OBJS:%.o=%.d)
-include $(LIB_DEP)
-include $(OBJ_DEP)

################
# ELF File
################

$(OBJ_DIR)/$(PROJ_NAME).elf: $(APP_OBJS) $(APP_LIBS)
	$(TRACE_LD)
	$(Q)$(LD) $(LDFLAGS) $(APP_OBJS) -Wl,--start-group $(APP_LIBS) $(EXTERNAL_LIBS) -Wl,--end-group -o $@

################
# HEX File
################

$(OBJ_DIR)/$(PROJ_NAME).hex: $(OBJ_DIR)/$(PROJ_NAME).elf
	$(OBJCOPY) -O ihex $< $(patsubst %.elf, %.hex, $^)

################
# BIN File
################

$(OBJ_DIR)/$(PROJ_NAME).bin: $(OBJ_DIR)/$(PROJ_NAME).elf
	$(OBJCOPY) -O binary $^ $@


##############################################################################
# Invoking Build Commands
##############################################################################

.PHONY: all
## Build a release binary
all: $(OBJ_DIR)/$(PROJ_NAME).bin

.PHONY: debug
## Build a debug binary
debug: $(OBJ_DIR)/$(PROJ_NAME).bin

.PHONY: clean
## Delete all generated files for current application
clean:
	rm -rf $(REPO_ROOT)/build
	rm -f $(SRC_DIR)/rpc_server_*.c 
	rm -f $(INC_DIR)/rpc_server.h 
	rm -f $(SRC_DIR)/rpc_client_*.c 
	rm -f $(INC_DIR)/rpc_client.h
	rm -f $(SRC_DIR)/gatt_efr32.c 
	rm -f $(INC_DIR)/gatt_efr32.h 
	rm -f $(SRC_DIR)/gatt_nrf52.c 
	rm -f $(INC_DIR)/gatt_nrf52.h
	rm -f *.map

.PHONY: clean_all
## Delete ALL generated files.
clean_all:
	rm -rf $(REPO_ROOT)/build
	rm -f $(APPS_DIR)/*/src/rpc_server_*.c
	rm -f $(APPS_DIR)/*/inc/rpc_server.h
	rm -f $(APPS_DIR)/*/src/rpc_client_*.c
	rm -f $(APPS_DIR)/*/inc/rpc_client.h
	rm -f $(APPS_DIR)/*/src/gatt_nrf52.c 
	rm -f $(APPS_DIR)/*/inc/gatt_nrf52.h 
	rm -f $(APPS_DIR)/*/src/gatt_efr32.c 
	rm -f $(APPS_DIR)/*/inc/gatt_efr32.h
	rm -f $(APPS_TEST_DIR)/*/src/rpc_server_*.c
	rm -f $(APPS_TEST_DIR)/*/inc/rpc_server.h
	rm -f $(APPS_TEST_DIR)/*/src/rpc_client_*.c
	rm -f $(APPS_TEST_DIR)/*/inc/rpc_client.h
	rm -f $(APPS_TEST_DIR)/*/src/gatt_efr32.c 
	rm -f $(APPS_TEST_DIR)/*/inc/gatt_efr32.h 
	rm -f $(APPS_TEST_DIR)/*/src/gatt_nrf52.c 
	rm -f $(APPS_TEST_DIR)/*/inc/gatt_nrf52.h
	rm -f *.map

##############################################################################
# Flashing Application Artifacts
##############################################################################

.PHONY: jlinksn
## List serial numbers of connected JLink Debuggers
jlinksn:
	@printf "\nConnected JLink Emulators\n" 
	@python3 -m programming.jlink --target $(TARGET) --print list
	@printf "\n"

.PHONY: flash_bootloader
## Fix a corrupted bootloader
flash_bootloader: $(CORE_CSIRO_DIR)/platform/$(TARGET)/bootloader_$(TARGET).s37
	$(REPO_ROOT)/tools/programming/flash.py bootloader --target $(TARGET) --binary $< $(JLINK_SN_PYTHON) $(REMOTE_JLINK)

.PHONY: flash flashdbg
## Flash the release binary | Flash the debug binary
flash flashdbg: $(OBJ_DIR)/$(PROJ_NAME).bin
	$(REPO_ROOT)/tools/programming/flash.py app --target $(TARGET) --binary $< $(JLINK_SN_PYTHON) $(REMOTE_JLINK)

.PHONY: flash_bin
## Flash a custom binary. Path (BIN) must be supplied.
flash_bin:
	$(REPO_ROOT)/tools/programming/flash.py app --target $(TARGET) --binary $(BIN) $(JLINK_SN_PYTHON) $(REMOTE_JLINK)

.PHONY: flashconst
## Flash a device with constants from that targets device_constants.csv file
flashconst:
	@# Preprocess the header file (required for pycparser)
	$(Q)$(CC) -E -DPYCPARSER $(foreach dir, $(CORE_CSIRO_INCS), -I$(dir)) $(CORE_CSIRO_DIR)/arch/common/nvm/inc/device_constants.h > /tmp/device_constants_$(TARGET).h_pp
	$(Q)$(REPO_ROOT)/tools/programming/flash.py constants --target $(TARGET) --header /tmp/device_constants_$(TARGET).h_pp --folder $(REPO_ROOT)/constants $(JLINK_SN_PYTHON) $(REMOTE_JLINK)

.PHONY: run
## Run the generated debug binary locally
run: $(OBJ_DIR)/$(PROJ_NAME).elf
	$(OBJ_DIR)/$(PROJ_NAME).elf

##############################################################################
# Debugging
##############################################################################

.PHONY: jlink
## Run JLinkExe and automatically connect with correct parameters
jlink:
	JLinkExe -device $(JLINK_CPU) -if $(JLINK_INTERFACE) -speed $(JLINK_SPEED) -autoconnect 1 $(JLINK_SN_EXE)

.PHONY: gdb
## Setup vscode launch.json for GDB debugging
gdb:
	@$(REPO_ROOT)/tools/vscode/generate_launch.py --debugger $(VSCODE_DEBUGGER)  --device $(JLINK_CPU) --elf $(realpath $(OBJ_DIR))/$(PROJ_NAME).elf $(SVD_OPTION) --dest $(REPO_ROOT)/.vscode $(JLINK_SN_PYTHON)
	
.PHONY: gdbserver
## Manually launch a GDB Server
gdbserver:
	JLinkGDBServer -device $(GDB_CPU) -port $(GDB_PORT) -if $(JLINK_INTERFACE) -speed $(JLINK_SPEED)

.PHONY: gdbrun
## Connect to a manually launched GDB Server
gdbrun:
	$(GDB) $(OBJ_DIR)/$(PROJ_NAME).elf --ex "target remote localhost:$(GDB_PORT)" --ex "b main" -ex "monitor reset" --ex "c"

.PHONY: dump
## Creates object dump of $(APP).elf
dump: debug
	$(OBJDUMP) -d $(OBJ_DIR)/$(PROJ_NAME).elf > dump.txt

##############################################################################
# Binary Releases
##############################################################################

.PHONY: release
## Upload a release binary to the TDF server
release:
	@$(REPO_ROOT)/tools/release/release.py --repo $(REPO_ROOT) --app $(PROJ_NAME) --target $(TARGET) --server "http://tdf.csiro.au"

##############################################################################
# Unit Testing
##############################################################################

.PHONY: test
## Runs unit tests
test: $(AUTOGEN_SRCS)
	make -C $(TEST_DIR) -f m_tests.mk all

.PHONY: coverage
## Runs code coverage reporting software
coverage: $(AUTOGEN_SRCS)
# Get all files, used or not, into the initial.info.
	$(Q)make -C $(TEST_DIR) -f m_tests.mk gcov
	$(Q)lcov --initial --capture --directory $(TEST_DIR)/build --output-file initial.info --quiet

# Trickery with gcov, lcov, genhtml, and bash scripts to format everything properly and do what we want.
# Inspiration from here: https://github.com/linux-test-project/lcov/issues/30
	$(Q)cat initial.info | awk -F '[:,]' '/^SF:/ { delete defs } /^FN:/ { defs[$$2]=1 } /^DA:/ { if ($$3 == 0 && $$2 in defs) next } { print }' > filteredinitial.info
	$(Q)lcov --capture --directory $(TEST_DIR)/build --output-file tested.info --quiet
	$(Q)lcov -a filteredinitial.info -a tested.info -o coverage.info --quiet
	$(Q)lcov --directory $(TEST_DIR)/build --remove coverage.info */core_external/* */unit_tests/* --output-file coverage.info --quiet
	$(Q)genhtml coverage.info --show-details --no-prefix --precision 2 --output-directory $(TEST_DIR)/build/out --quiet

# Print output
	$(Q)echo
	$(Q)echo "${GREEN}For a graphical coverage report, hold 'command' and double click this link, or navigate to the URL in your browser:"
	$(Q)echo "file://$(realpath $(REPO_ROOT))/unit_tests/build/out/index.html${RESET}"
	$(Q)echo
	$(Q)lcov --directory $(TEST_DIR)/build --summary coverage.info
	$(Q)rm coverage.info tested.info initial.info filteredinitial.info
	$(Q)echo

.PHONY: test_clean
## Cleans unit tests
test_clean:
	make -C $(TEST_DIR) -f m_tests.mk clean

.PHONY: test_python
## Runs python unit tests
test_python:
	python3 -m unittest discover $(REPO_ROOT)

##############################################################################

TARGET_MAX_CHAR_NUM=20

## Show help
help:
	@echo ''
	@echo 'Usage:'
	@echo '  ${YELLOW}make${RESET} ${GREEN}<target>${RESET}'
	@echo ''
	@echo 'Targets:'
	@echo ''
	@awk '/^[a-zA-Z0-9_ ]+:/ { \
		helpMessage = match(lastLine, /^## (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")-1); \
			if (!helpCommand) { \
 				helpCommand = substr($$1, 0, 20); \
				helpMessage = substr(lastLine, 4, index(lastLine, "|")-5); \
				printf "  ${YELLOW}%-$(TARGET_MAX_CHAR_NUM)s${RESET} ${GREEN}%s${RESET}\n", helpCommand, helpMessage; \
				helpCommand = substr($$2, 0, index($$2, ":")-1); \
				helpMessage = substr(lastLine, index(lastLine, "|")+2, RLENGTH); \
				printf "  ${YELLOW}%-$(TARGET_MAX_CHAR_NUM)s${RESET} ${GREEN}%s${RESET}\n", helpCommand, helpMessage; \
			} else { \
				helpMessage = substr(lastLine, RSTART + 3, RLENGTH); \
				printf "  ${YELLOW}%-$(TARGET_MAX_CHAR_NUM)s${RESET} ${GREEN}%s${RESET}\n", helpCommand, helpMessage; \
			} \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)

##############################################################################

gatt:
rpc:
